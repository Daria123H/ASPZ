# Налаштування

Docker — це інструмент, який допомагає запускати програми в спеціальних контейнерах. Мета цієї практичної було дослідити та проексперементувати з обмеженнями ресурсів у середовищі Docker. Я маю на увазі освоїти ліміт відкритих файлів, встановлення лімітів процесів та файлів, використання утиліти perf, обмеження на максимальний розмір файлу, часу та інше. В моїй ситуації в мене встановлено FreeBSD на якій я не могу встановити середовище докер бо він працює з лінуксом та не втає на FreeBSD тому я знайшла альтернативу докеру це jail. Це як середовище як процесів в FreeBSD. Але перед тим як працювати з цим середовищем треба його встановити та налаштувати. Спочатку я встановила пакет

            pkg install ezjail

Далі налаштувала систему для роботи з rctl та sysctl. Далі створила файл з конфігурацією jail «jail.conf». Далі прописала команди для системи для роботи jail

            sysrc jail_enable="YES"

            sysrc jail_list="testjail"

Далі перезапустила сервіс jail та запустила його за допомогою цієї команди

            service ezjail start

далі перевірила що він дійсно працює

            jls

потім увімкнула наступну команду щоб увійти в jail

            jexec testjail /bin/sh.

Додатково створила директорії для jail 

            mkdir -p /usr/jails/testjail

і скопіювала в них базові файли системи

            tar -xvpf /usr/freebsd-dist/base.txz -C /usr/jails/testjail

            tar -xvpf /usr/freebsd-dist/kernel.txz -C /usr/jails/testjail.

# Завдання 3.1

Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. Для цього виконайте команди у вказаному порядку:

      $ ulimit -n
      $ ulimit -aS | grep "open files"
      $ ulimit -aH | grep "open files"
      $ ulimit -n 3000
      $ ulimit -aS | grep "open files"
      $ ulimit -aH | grep "open files"
      $ ulimit -n 3001
      $ ulimit -n 2000
      $ ulimit -n
      $ ulimit -aS | grep "open files"
      $ ulimit -aH | grep "open files"
      $ ulimit -n 3000

Як наступне вправу, повторіть перераховані команди з root-правами.

## Виконання

За допомогою середовища jail я виконала завдання на обмеження кількості відкритих файлів. По черзі прописала всі запропоновані команди суть яких змінювати ліміт і перевіряти що вони дійсно змінюються. На рахунок root прав я спочатку заходила в root, а потім вже в jail, тобто я вже знаходилась в root. 

### Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task1/PR3_1.png)

# Завдання 3.2

У Docker-контейнері встановіть утиліту perf(1). Поекспериментуйте з досягненням процесом встановленого ліміту.

## Виконання

За цим завданням потрібно було встановити утиліту perf, але так як вона відсутня у FreeBSD замість неї я використала альтернативний спосіб моніторингу. Перше це провела аналіз навантаження на CPU у реальному часі далі встановила оновлення кожну секунду після цього запустила команду vmstat 1

Щоб подивитись загальне навантаження системи. Потім перевірила, які ліміти процесів встановлено в системі: 

            ulimit -a
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task2/Pr32_1.png)

            ulimit -t

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task2/PR32_2.png)

Далі проаналізувала процеси які споживають найбільше ресурсів. 

            ps aux | sort -nrk 3 | head -10
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task2/Pr32_3.png)

Далі запустила навантажувальний тест, щоб подивитись як змінюватимуться ресурси. 

            yes > /dev/null &

яка запускає нескінченний процес завантаження CPU

Після запуску виконала команду 

            vmstat 1

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task2/Pr32_4.png)

щоб подивитися, як змінюються показники. 

# Завдання 3.3

Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3/Pr33.c).

### Компілюю та у результаті: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3/PR3_3.png)

У файлі:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3/PR3_33.png)

Програма починається з визначення макросів. FILENAME задає ім'я файлу, куди записуватимуться результати кидків. MAX_FILE_SIZE встановлює максимальний розмір файлу у 1024 байти. BATCH_SIZE визначає кількість кидків кубика за один цикл запису. Функція roll_dice() відповідає за генерацію випадкового числа від 1 до 6, що імітує кидок шестигранного кубика. Потім виконується відкриття файлу за допомогою open(FILENAME, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR), що дозволяє здійснювати запис, створює файл за його відсутності та додає дані в кінець. Якщо відкриття не вдалося, програма завершується з помилкою. Основний цикл починається з виклику stat(FILENAME, &file_stat), який отримує поточний розмір файлу. Якщо розмір перевищує MAX_FILE_SIZE, програма припиняє виконання. Далі генерується BATCH_SIZE випадкових кидків кубика, після чого перевіряється, чи новий запис не перевищить допустимий розмір файлу. Якщо обмеження не порушується, результати записуються у файл. Завершальний етап – закриття файлу командою close(fd), що гарантує правильне завершення роботи програми.

# Завдання 3.4

Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.

## Виконання

Це завдання подібне до попереднього. 
[Переглянути код](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task4/PR3_4.c).

Компіляцію наступним чином відбувається і отримаємо результат:

            root@host:/home/dasha # python3 PR3_4.py

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task4/Pr34.png)

У файлі: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task4/PR3_44.png)

Ми задаємося обмеженням на час ЦП через ulimit -t 5 (5 секунд), запускаємо программу і через 5 секунд вона завершується і за цей час імітує лотерею, тобто коли вичерпався час ЦП, програма завершується, а результати записуються у файл.

# Завдання 3.5

Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.
Програма має:

            ● перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";

            ● перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";

            ● перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";

            ● обробляти ситуацію перевищення обмеження на розмір файлу.

## Виконання

Для даного завдання я створила файл з [кодом на пайтон](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR3_5.py), який перевіряє чи передається два аргументи, перевіряє чи існує вихідний файл, обробляє перевищення розміру файлу. За допомогою наступної команди створила вихідний файл, тобто джерело і цільовий.

            echo "Hello World" > file1.txt

            touch file2.txt 

            ls -l file1.txt file2.txt
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR35_2.png)

Після цього запустила програму

            python3 PR3_5.py file1.txt file2.txt.
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR35_3.png)

За допомогою цієї команди перевіряємо чи містяться там дані

            cat file2.txt
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR35_1.png)

і за завданням потрібно було перевірити помилки, тобто викликати програму без аргументів або з неіснуючим файлом. 

            python3 PR3_5.py

            python3 PR3_5.py file_not_exist.txt file2.txt

            python3 PR3_5.py file1.txt /root/protected_file.txt  
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR3_555.png) 
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task5/PR3_5555.png) 


# Завдання 3.6

Напишіть програму, що демонструє використання обмеження (max stack segment size). Підказка: рекурсивна програма активно використовує стек.

## Виконання

Нашим завданням було продемонструвати обмеження розміру стеку в системі за допомогою рекурсивної функції. Щоб запустити код нам потрібно дізнатися який в системі ліміт на стек за допомогою команди 

            ulimit -s

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task6/PR3_6.png) 

Далі написали [програму](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task6/PR36_1.py)

Ми створили нескінчену рекурсію щоб викликати помилку стеку. Запустивши код через деякий час ми отримали помилку. 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task6/PR3_61.png) 

Далі зменшили обмеження стеку

            ulimit -s 512

після цього запустили програму і помилка виникла швидше.

# Завдання 3.21

Дослідити взаємодію ulimit та cgroups у Docker.

## Виконання

Для початку перевірила поточні ліміти

            Ulimit -a
            
![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3_21/PR3_21_1.png) 

Далі обмежила кількість відкритих файлів

            Ulimit -n 1024

Далі обмежила максимальний розмір пам’яті для процесу 

            Ulimit -m 524288

Далі обмежила пам’ять для процесу через підтримку rctl

            sysrc rctl_enable="YES"

            service rctl start

Додала обмеження для процесу sleep

            sleep 1000 &

            pgrep sleep

Обмежила процес

            rctl -a process:2339:memoryuse:deny=256M

І перевірила обмеження

            rctl -l process:2339

Далі перевірила чи rctl працює обмеження на пам’ять тому запустила тест 

            dd if=/dev/zero of=/dev/null bs=1M count=300

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3_21/PR3_21_2.png) 

Процес завершився помилкою через обмеження пам’яті тому rctl працює

Далі перевірила чи є обмеження на CPU тому запустила важкий процес 

            openssl speed

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3_21/PR3_21_3.png) 

Перевірила, чи не перевищує використання CPU 50%:

            top -P.

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr3/task3_21/PR3_21_4.png) 
