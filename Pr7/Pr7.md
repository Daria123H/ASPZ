Посилання:https://github.com/Daria123H/ASPZ.git

# Завдання 7.1

Використайте popen(), щоб передати вивід команди rwho (команда UNIX) до more (команда UNIX) у програмі на C.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_1/PR7_1.c), який використовує функцію popen() для виконання команди rwho | more, яка виводить список користувачів у мережі з можливістю перегляду сторінками. Відкривається пайп на читання виводу команди, результат зчитується рядками через fgets() і виводиться на екран за допомогою fputs(). У випадку помилки відкриття пайпа виводиться повідомлення про помилку. Після завершення зчитування пайп закривається функцією pclose().

Компілюємо код та запускаємо:

    clang -o Pr7_1 Pr7_1.c
    ./Pr7_1
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_1/PR7_1.png)

Вивід пустий, бо коли ми використовуємо popen("rwho | more", "r"), програма читає вивід more, але не через термінал напряму, а у вигляді рядків у fgets(). Оскільки more це інтерфейсна команда, вона очікує інтерфейс з терміналом, і в такому режимі (через popen) вона може нічого не показати або одразу завершитись, бо не бачить TTY і не знає, як відобразити результат.

# Завдання 7.2

Напишіть програму мовою C, яка імітує команду ls -l в UNIX — виводить список усіх файлів у поточному каталозі та перелічує права доступу тощо. (Варіант вирішення, що просто виконує ls -l із вашої програми, — не підходить.)

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_2/PR7_2.c), який імітує команду ls -l в UNIX, виводячи список файлів у поточному каталозі. Для кожного файлу програма виводить інформацію про його тип (наприклад, чи це директорія або звичайний файл), права доступу (читання, запис, виконання для власника, групи та інших), кількість посилань на файл, ім’я власника та групи, розмір файлу в байтах, час останньої зміни та ім’я самого файлу. Програма пропускає приховані файли (які починаються з крапки). Використовуються стандартні функції для роботи з файлами та каталогами, такі як opendir, readdir, stat, а також функції для отримання інформації про власника та групу файлів (getpwuid, getgrgid).

Компілюємо код та запускаємо:

    clang -o Pr7_2 Pr7_2.c
    ./Pr7_2
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_2/PR7_2.png)

# Завдання 7.3

Напишіть програму, яка друкує рядки з файлу, що містять слово, передане як аргумент програми (проста версія утиліти grep в UNIX).

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_3/PR7_3.c), яка читає текстовий файл і виводить лише ті рядки, в яких зустрічається задане слово. Спочатку вона перевіряє, чи користувач передав два аргументи: ім’я файлу та слово для пошуку. Якщо ні — показує, як правильно запускати програму, і завершує роботу. Потім вона намагається відкрити файл для читання. Якщо файл не відкрився, виводиться повідомлення про помилку. Далі програма читає файл построково, і для кожного рядка перевіряє, чи міститься в ньому шукане слово. Якщо слово є, цей рядок виводиться на екран. Наприкінці файл закривається.

Компілюємо код та запускаємо:

    clang -o Pr7_3 Pr7_3.c
    ./Pr7_3
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_3/PR7_3.png)

# Завдання 7.4

Напишіть програму, яка виводить список файлів, заданих у вигляді аргументів, з зупинкою кожні 20 рядків, доки не буде натиснута клавіша (спрощена версія утиліти more в UNIX).

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_4/PR7_4.c), 

Компілюємо код та запускаємо:

    clang -o Pr7_4 Pr7_4.c
    ./Pr7_4
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_4/PR7_4.png)

# Завдання 7.5

Напишіть програму, яка перелічує всі файли в поточному каталозі та всі файли в підкаталогах.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_5/PR7_5.c), який перераховує всі файли в поточному каталозі та в його підкаталогах. Він використовує функцію list_files, яка відкриває вказаний каталог, читає його вміст і для кожного елемента перевіряє, чи не є він спеціальними каталогами "." або "..". Якщо це підкаталог, функція викликає саму себе рекурсивно, щоб обійти і його. Якщо це звичайний файл, його шлях виводиться на екран. У функції main програма починає з поточного каталогу ".". В результаті виводиться список усіх файлів у поточній папці та всіх її вкладених папках.

Компілюємо код та запускаємо:

    clang -o Pr7_5 Pr7_5.c
    ./Pr7_4
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_5/PR7_5.png)

# Завдання 7.6

 Напишіть програму, яка перелічує лише підкаталоги у алфавітному порядку.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_6/PR7_6.c), який перераховує всі файли в поточному каталозі та в його підкаталогах. Він використовує функцію list_files, яка відкриває вказаний каталог, читає його вміст і для кожного елемента перевіряє, чи не є він спеціальними каталогами "." або "..". Якщо це підкаталог, функція викликає саму себе рекурсивно, щоб обійти і його. Якщо це звичайний файл, його шлях виводиться на екран. У функції main програма починає з поточного каталогу ".". В результаті виводиться список усіх файлів у поточній папці та всіх її вкладених папках.

Компілюємо код та запускаємо:

    clang -o Pr7_6 Pr7_6.c
    ./Pr7_6
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_6/PR7_6.png)

# Завдання 7.7

Напишіть програму, яка показує користувачу всі його/її вихідні програми на C, а потім в інтерактивному режимі запитує, чи потрібно надати іншим дозвіл на читання (read permission); у разі ствердної відповіді — такий дозвіл повинен бути наданий.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_7/PR7_7.c), який відкриває поточну теку (де вона запущена) і перевіряє кожен файл у цій теці. Якщо файл є звичайним (не текою, не посиланням) і має дозвіл на виконання власником (тобто, це, ймовірно, програма), програма показує його назву на екрані й запитує користувача, чи потрібно надати іншим користувачам дозвіл на читання цього файла. Якщо користувач вводить y або Y, програма додає файлe дозвіл на читання для інших (тобто додає r-- для others у правах доступу). У кінці програма закриває теку й завершується.

Компілюємо код та запускаємо:

    clang -o Pr7_7 Pr7_7.c
    ./Pr7_7
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_7/PR7_7.png)

# Завдання 7.8

Напишіть програму, яка надає користувачу можливість видалити будь-який або всі файли у поточному робочому каталозі. Має з’являтися ім’я файлу з запитом, чи слід його видалити.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_8/PR7_8.py), який проходить по всіх файлах у поточному каталозі та запитує користувача, чи хоче він видалити кожен файл. Якщо користувач відповідає "y", файл буде видалено, і програма повідомить про це. Якщо відповідь "n", файл залишиться. Якщо під час видалення виникає помилка, програма виведе повідомлення про помилку.

Компілюємо код та запускаємо:

    python3 PR7_8.py
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_8/PR7_8.png)

# Завдання 7.9

Напишіть програму на C, яка вимірює час виконання фрагмента коду в мілісекундах.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_9/PR7_9.c), в якому спочатку оголошується дві змінні типу struct timespec — start та end, які використовуються для зберігання часу до та після виконання коду. За допомогою функції clock_gettime(CLOCK_MONOTONIC, &start) програма отримує поточний час перед виконанням фрагмента коду і зберігає його в змінній start. Потім виконується сам фрагмент коду (в даному випадку це просто цикл, який нічого не робить, але можна вставити будь-який код, час виконання якого потрібно виміряти). Після цього за допомогою функції clock_gettime(CLOCK_MONOTONIC, &end) програма знову отримує поточний час, але вже після виконання коду, і зберігає його в змінній end. Різниця між часом, який був до та після виконання коду, обчислюється в мілісекундах. Для цього віднімаються значення секунд та наносекунд, які містяться в структурах start та end. Оскільки наносекунди можуть бути більше або менше 1 секунди, програма коригує результат, якщо різниця по наносекундах від'ємна. Результат виводиться на екран у мілісекундах з точністю до трьох знаків після коми.

Компілюємо код та запускаємо:

    clang -o Pr7_9 Pr7_9.c
    ./Pr7_9
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_9/PR7_9.png)

# Завдання 7.10

Напишіть програму мовою C для створення послідовності випадкових чисел з плаваючою комою у діапазонах:
 (a) від 0.0 до 1.0
 (b) від 0.0 до n, де n — будь-яке дійсне число з плаваючою точкою.
 Початкове значення генератора випадкових чисел має бути встановлене так, щоб гарантувати унікальну послідовність.
Примітка: використання прапорця -Wall під час компіляції є обов’язковим.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_10/PR7_10.c), який створює і виводить випадкові числа з плаваючою точкою. Спочатку програма просить користувача ввести число n. Потім генерує 10 випадкових чисел у межах від 0.0 до 1.0, а після цього - ще 10 чисел у межах від 0.0 до введеного n. Для забезпечення унікальності послідовності кожного запуску використовується поточний час як початкове значення для генератора випадкових чисел.

Компілюємо код та запускаємо:

    clang -Wall PR7_10.c -o PR7_10
    ./Pr7_10
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_10/PR7_10.png)

# Завдання 7.21

Напишіть утиліту, яка аналізує "заплутаність" структури директорій за спеціальним критерієм вашого вибору.

## Виконання 

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr7/Pr7_21.c) на С, який рахує скільки всього директорій,  визначає максимальну глибину вкладення, обчислює середню глибину. Користувач запускає програму і 
передає їй шлях до тієї директорії, яку хоче перевірити. Програма перевіряє, чи шлях переданий, і якщо так — запускає основну функцію walk() з глибиною 0. Функція walk() відкриває вказану директорію й читає її вміст — тобто список файлів і папок.  Для кожного елемента вона перевіряє — чи це папка. Якщо так, то збільшує лічильник загальної кількості папок (dirs++), додає її глибину до загального підсумку (depth_sum += глибина), порівнює глибину з поточним максимумом і оновлює, якщо треба (max_depth). Після цього вона рекурсивно викликає саму себе, щоб обійти всі вкладені папки ще глибше. Таким чином, програма “залазить” у кожну підпапку і поступово накопичує статистику: скільки було папок, наскільки вони були глибоко вкладені. Коли все обійдено, програма повертається до main() і виводить результат. 

Далі створюю тестову структуру директорій:

    mkdir -p test/a/b/c

Компілюємо код та запускаємо:

    cc Pr7_21.c -o Pr7_21
    ./Pr7_21 test
    
## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr7/PR7_21.png)

    Директорій: 3 — це a, b, c (ті, що всередині test).
    Макс. глибина: 3 — c знаходиться на третьому рівні вкладення.
    Сер. глибина: 2.00 — середнє з (1 + 2 + 3) / 3 = 2.00



