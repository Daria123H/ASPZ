Посилання:https://github.com/Daria123H/ASPZ.git

# Завдання 9.1

   Напишіть програму, яка читає файл /etc/passwd за допомогою команди getent passwd, щоб дізнатись, які облікові записи визначені на вашому комп’ютері. Програма повинна визначити, чи є серед них звичайні користувачі (ідентифікатори UID повинні бути більші за 500 або 1000, залежно від вашого дистрибутива), окрім вас.
   
## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_1/PR9_1.py), який за допомогою команди getent passwd читає інформацію про всі облікові записи користувачів із системного файлу /etc/passwd. Далі вона визначає ім'я користувача, його UID (ідентифікатор користувача) і порівнює ці дані. Програма перевіряє, чи є серед облікових записів звичайні користувачі — ті, у кого UID більший або дорівнює 1000, і чиє ім'я не збігається з поточним користувачем та не є службовим користувачем nobody. Якщо такі користувачі знаходяться, їх імена і UID виводяться на екран. Якщо жодного іншого звичайного користувача не знайдено, програма виводить повідомлення "No other regular users found".

Запускаємо: 

    python3 PR9_1.py

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_1/PR9_1.png)

Вивід означає, що є тільки мій обліковий запис (dasha, UID 1001). Інших звичайних користувачів (UID ≥ 1000, і не службових типу nobody) немає.

# Завдання 9.2

  Напишіть програму, яка виконує команду cat /etc/shadow від імені адміністратора, хоча запускається від звичайного користувача. (Ваша програма повинна робити необхідне, виходячи з того, що конфігурація системи дозволяє отримувати адміністративний доступ за допомогою відповідної команди.)

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_2/PR9_2.py), який запускає команду для перегляду вмісту системного файлу, який доступний тільки адміністраторам. Програма використовує команду sudo, щоб отримати права адміністратора. Якщо команда виконується правильно, вона виводить вміст файлу на екран, а якщо виникає помилка, то виводиться повідомлення про помилку.

Запускаємо код, вводимо пароль та отримуємо результат

    python3 PR9_2.py
    password:

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_2/PR9_2.png)

Запис для користувача dasha вказує на те, що система має зашифрований пароль користувача. Це підтверджує, що файл /etc/master.passwd містить важливу інформацію про користувачів, зокрема їхні паролі.

# Завдання 9.3

Напишіть програму, яка від імені root копіює файл, який вона перед цим створила від імені звичайного користувача. Потім вона повинна помістити копію у домашній каталог звичайного користувача. Далі, використовуючи звичайний обліковий запис, програма намагається змінити файл і зберегти зміни. Що відбудеться? Після цього програма намагається видалити цей файл за допомогою команди rm. Що відбудеться?

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_3/PR9_3.c), який створює файл з текстом, а потім копіює його в інший файл з правами адміністратора. Після цього програма намагається відкрити цей файл для редагування, використовуючи права адміністратора. Потім вона намагається видалити цей файл, також з правами адміністратора. В результаті файл буде успішно скопійований, змінений і видалений.

Запускаємо код, вводимо пароль та отримуємо результат

    clang PR9_3.c -o PR9_3
    ./PR9_3 
    password:

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_3/PR9_3copy.png)

# Завдання 9.4

Напишіть програму, яка по черзі виконує команди whoami та id, щоб перевірити стан облікового запису користувача, від імені якого вона запущена. Є ймовірність, що команда id виведе список різних груп, до яких ви належите. Програма повинна це продемонструвати.

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/tree/main/Pr9/PR9_4), який виконує команди whoami та id, і виводить результат на екран, демонструючи, до яких груп належить поточний користувач. 

Запускаємо код, вводимо пароль та отримуємо результат

    clang -o PR9_4 PR9_4.c
    ./PR9_4

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_4/PR9_4.png)

uid=1001(dasha) - це ідентифікатор користувача, вказує на користувача з іменем "dasha" і його UID (User ID) 1001.

gid=1001(dasha) - це груповий ідентифікатор користувача "dasha", де GID (Group ID) також 1001.

groups=1001(dasha), 0(wheel) - це список груп, до яких належить користувач. Користувач "dasha" належить до групи з GID 1001 (ім'я групи "dasha") і до групи з GID 0 (ім'я групи "wheel"), яка зазвичай надає адміністративні права.

# Завдання 9.5

Напишіть програму, яка створює тимчасовий файл від імені звичайного користувача. Потім від імені суперкористувача використовує команди chown і chmod, щоб змінити тип володіння та права доступу. Програма повинна визначити, в яких випадках вона може виконувати читання та запис файлу, використовуючи свій обліковий запис.

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_5/PR9_5.c), який створює тимчасовий файл /tmp/tempfile.txt, записує в нього текст, а потім змінює власника файлу на користувача root та групу на wheel, а також надає йому права доступу 644. Після цього програма перевіряє, чи має поточний користувач права на читання та запис цього файлу за допомогою функції access. Якщо користувач має відповідні права, програма виводить повідомлення, що підтверджує ці права, в іншому випадку повідомляє, що прав немає.

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_5/PR9_5.png)

# Завдання 9.6

Напишіть програму, яка виконує команду ls -l, щоб переглянути власника і права доступу до файлів у своєму домашньому каталозі, в /usr/bin та в /etc. Продемонструйте, як ваша програма намагається обійти різні власники та права доступу користувачів, а також здійснює спроби читання, запису та виконання цих файлів.

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_6/PR9_6.c), яка виконує перевірку прав доступу до файлів у трьох каталогах: домашньому каталозі користувача, /usr/bin та /etc. Для кожного файлу в цих каталогах програма виводить інформацію про права доступу (читання, запис, виконання) для власника, групи та інших користувачів, а також перевіряє, чи доступні ці файли для читання, запису та виконання для поточного користувача. Програма використовує функцію stat, щоб отримати інформацію про файл, зокрема його права доступу. За допомогою бітових операцій програма визначає, чи має користувач права на читання, запис і виконання файлів для кожної з трьох категорій: власник, група та інші користувачі. Також за допомогою функції access перевіряється, чи може поточний користувач читати, записувати або виконувати файл. Програма виводить відповідні повідомлення для кожного файлу: чи доступний він для читання, запису і виконання. Програма спочатку відображає права доступу для файлів у домашньому каталозі користувача, потім у каталозі /usr/bin і в /etc. Вона пропускає файли, що починаються з крапки (приховані файли), і виводить інформацію тільки про звичайні файли. Це демонструє, як програма може перевірити і обійти різні права доступу для файлів та дозволи для різних користувачів (власник, група, інші).

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_6/PR9_6.png)

# Завдання 9.21

Як змінюється доступ до файлу, якщо його жорстке посилання видалено, але процес ще використовує файл?

## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_21/PR9_21.c), який демонструє, як змінюється доступ до файлу, коли його жорстке посилання видалено, але процес все ще використовує файл.  Програма створює файл example.txt та записує в нього деякий текст. Потім створюється жорстке посилання example_link.txt на цей файл. Тепер обидва файли вказують на одну і ту ж саму область даних на диску. Програма знову відкриває файл example.txt для читання. Потім видаляється оригінальний файл example.txt, але жорстке посилання example_link.txt ще існує, тому дані на диску залишаються доступними. Програма читає вміст файлу через відкрите посилання на example.txt і виводить його на екран. Наприкінці програма закриває файл. Оскільки процес все ще використовує файл через посилання, навіть після того, як оригінальний файл було видалено, вміст залишається доступним для читання. Жорстке посилання дозволяє продовжувати доступ до даних файлу, поки процес не закриє його дескриптор.

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr9/PR9_21/PR9_7.png)
