Посилання:https://github.com/Daria123H/ASPZ.git

# Завдання 14.21

   Дослідіть поведінку таймерів у багатопоточному додатку — створіть таймер у кожному потоці і порівняйте результат.
   
## Виконання

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr14/PR14_21.c), який створює п’ять потоків, кожен з яких працює паралельно. У кожному потоці виконується функція, що чекає 2 секунди (імітує роботу таймера), після чого виводить повідомлення з номером потоку, який завершив роботу. В основній функції main спочатку оголошуються масив потоків і масив з номерами для кожного потоку. Далі запускаються п’ять потоків, кожному передається свій номер. Потоки працюють одночасно, і кожен робить паузу у 2 секунди, після чого виводить повідомлення. Після запуску всіх потоків головна програма чекає, поки всі вони завершаться, щоб не закінчитися раніше. Таким чином, код демонструє, як одночасно у кількох потоках можна виконувати затримку та отримати індивідуальний результат від кожного потоку.

Запускаємо: 

    gcc -pthread -o PR14_21 PR14_21.c
    ./PR14_21

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr14/PR14_21.png)

# Завдання alarm.c

Пишемо [код](https://github.com/Daria123H/ASPZ/blob/main/Pr14/alarm.c), який реалізує простий CLI цифровий годинник на основі сигналів та таймерів UNIX. Таймер налаштовано через виклик функції alarm(1), який щосекунди запускає сигнал SIGALRM. Завдяки цьому у обробнику сигналу можна оновлювати вивід часу. Функція h є обробником сигналу, що викликається при отриманні SIGALRM. У ній спочатку отримуємо поточний час за допомогою time(NULL) і конвертуємо його у локальний формат за допомогою localtime(). Потім форматумо час у вигляді рядка "HH:MM:SS" за допомогою strftime(). Для виводу часу у консоль використовується системний виклик write(), а не printf(), оскільки write() є reentrant-безпечним і безпечним для виклику всередині обробника сигналів, де виклики складних функцій можуть бути небажаними. Повертаємо курсор у початок рядка за допомогою символу '\r', щоб новий вивід замінював попередній, що дозволяє оновлювати годинник на одному рядку. Після цього знову викликаємо alarm(1), щоб наступний сигнал надійшов через секунду, реалізуючи циклічне оновлення часу. У основному циклі програма виконує нескінченне очікування сигналів за допомогою функції pause(), не виконуючи жодних дій, доки не отримає сигнал SIGALRM, який знову запускає обробник для оновлення часу.

### Результат

 ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr14/%7B7BFC2458-AE8D-4B08-8755-2D09E242C7B4%7D.png)

