# Завдання 2.1

Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

## Виконання

Спочатку створюю файл за допомогою команди

ee PR2_1.c

[Створила C-програму](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task1/PR2_1.c), яка визначає максимальне значення time_t.

Далі компілюю через clang

Clang -o PR2_1 PR2_1.c

./PR2_1

### Пояснення

Програма визначає, коли значення time_t досягне свого максимального значення і "закінчиться".  Виведення значення time_t як -1 означає, що значення "закінчується" до 1970 року, коли час представляється від'ємним числом. Різниця в сегментах виконуваного файлу між 32-бітними та 64-бітними системами полягає у розмірі змінних для зберігання time_t: на 64-бітних системах це більше значення у порівнянні з 32-бітною.

## Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task1/PR2_1.png)

# Завдання 2.2

Розгляньте сегменти у виконуваному файлі.

Розгляньте сегменти у виконуваному файлі.

    1. Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
    
    2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
    
    3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
    
    4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
    
    5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
    
Проаналізуйте результати, щоб переконатися, що:

● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти. 

## Виконання

Спочатку створюю файл за допомогою команди  

ee PR22.c

Перший кроком було написання програми ["hello world"](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22.c) :

компіляція і запуск її через

ls -l PR22

Ця команда показує список файлів у поточній папці  з детальною інформацією. 

## Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22.png)

Додатково перевірила розмір сегментів за допомогою:

size PR22

Сегмент — це частина файлу або даних, яка зберігається окремо в пам'яті або на диску.
 
Розмір сегментів – це характеристика файлів або даних, що вказує, як вони розподілені та використовують дисковий простір.

## У результаті вивід буде наступний: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/segments.png)

Ось окремо про кожен сегмент:

Сегмент text — це місце, де зберігається сам код програми, тобто команди, які виконує процесор.

Сегмент data — це область пам’яті, де зберігаються глобальні та статичні змінні, яким одразу надано значення.

Сегмент BSS — це область для неініціалізованих глобальних змінних.

DEC — це загальний розмір цих сегментів у десятковій системі числення.

HEX  — те саме, тільки у шістнадцятковій системі числення.

Наступним кроком в цьому завданні було оголошення масиву. [Код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_1.c) вже мав наступний вигляд: 

Повторюємо вимірювання і у результаті маємо вивід:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/with%20global%20array_1.png)

Та

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/with%20global%20array.png)

BSS значно збільшився з 1856 до 5856. Це пояснюється тим, що масив оголошено, але не ініціалізовано. Він не займає місце у виконуваному файлі, але програма резервує під нього пам’ять під час виконання.

Третім кроком було надання значення масиву. 

[Код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_2.c):

Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_2.png)

Тут вже BSS повернувся до 1856, бо масив тепер ініціалізований і перемістився у сегмент data. Data виріс з 440 до 4448, оскільки тепер дані знаходяться у виконуваному файлі. Файл збільшився в розмірі, бо тепер у ньому зберігаються значення масиву.

Наступний етап це оголошення великого масиву в локальну функцію та другого великого локального масиву з ініціалізатором.

[Код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_3.c):

Результат: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_3.png)

І на останньому етапі Text зріс із 1161 до 1270 — можливо, через додавання нової функції. BSS виріс із 1856 до 5744, бо додано статичні змінні, що не мають ініціалізованих значень. Data не змінився, бо статичний масив із ініціалізацією вже обліковувався раніше.

Чи залишаються дані у виконуваному файлі, якщо вони знаходяться всередині функцій?

Якщо змінні знаходяться всередині функцій, вони можуть залишатися у виконуваному файлі, але все залежить від їхнього типу. Якщо це звичайні локальні змінні (наприклад, int localArray[1000];), вони з’являються тільки під час виконання програми й не впливають на розмір файлу. Якщо змінна оголошена як static, вона зберігається в спеціальній області пам’яті та вже є частиною файлу, особливо якщо вона має початкове значення.

Яка різниця між ініціалізованим і неініціалізованим масивом?

Різниця між ініціалізованим і неініціалізованим масивом така: якщо просто оголосити масив, але не дати йому значень, він потрапить у пам’ять тільки під час виконання програми, тому файл не стане більшим. Але якщо масив одразу отримує значення (int globalArray[1000] = {1};), ці дані зберігаються прямо у виконуваному файлі, тому він займає більше місця.

Чому змінився розмір виконуваного файлу?

Розмір файлу змінюється тому, що ініціалізовані дані повинні десь зберігатися ще до запуску програми, а значить, вони додаються у файл. Неініціалізовані масиви просто резервують місце в пам’яті під час роботи програми, тому на розмір файлу вони майже не впливають.

Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?

Коли я компілюю програму для налагодження, її розмір значно збільшується, тому що у файл додається купа додаткової інформації. Сам код при цьому не змінюється, тому розміри сегментів text, data і bss зазвичай залишаються такими ж, але сам виконуваний файл стає набагато більшим. А якщо я компілюю з максимальною оптимізацією, то файл, навпаки, може стати меншим. Компілятор видаляє зайвий код, спрощує, використовує швидші алгоритми і краще працює з пам’яттю. У результаті сегмент text часто зменшується, бо код займає менше місця. Сегменти data і bss теж можуть трохи змінитися, якщо компілятор вирішить інакше розташувати змінні. 
