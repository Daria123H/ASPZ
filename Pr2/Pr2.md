# Завдання 2.1

Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

## Виконання

Спочатку створюю файл за допомогою команди

ee PR2_1.c

[Створила C-програму](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task1/PR2_1.c), яка визначає максимальне значення time_t.

Далі компілюю через clang

Clang -o PR2_1 PR2_1.c

./PR2_1

### Пояснення

Програма визначає, коли значення time_t досягне свого максимального значення і "закінчиться".  Виведення значення time_t як -1 означає, що значення "закінчується" до 1970 року, коли час представляється від'ємним числом. Різниця в сегментах виконуваного файлу між 32-бітними та 64-бітними системами полягає у розмірі змінних для зберігання time_t: на 64-бітних системах це більше значення у порівнянні з 32-бітною.

## Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task1/PR2_1.png)

# Завдання 2.2

Розгляньте сегменти у виконуваному файлі.

    1. Скомпілюйте програму "hello world", запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
    
    2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
    
    3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
    
    4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
    
    5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?
    
Проаналізуйте результати, щоб переконатися, що:

● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти. 

## Виконання

Спочатку створюю файл за допомогою команди  

ee PR22.c

Перший кроком було написання програми ["hello world"](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22.c) :

компіляція і запуск її через

ls -l PR22

Ця команда показує список файлів у поточній папці  з детальною інформацією. 

### Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22.png)

Додатково перевірила розмір сегментів за допомогою:

size PR22

Сегмент — це частина файлу або даних, яка зберігається окремо в пам'яті або на диску.
 
Розмір сегментів – це характеристика файлів або даних, що вказує, як вони розподілені та використовують дисковий простір.

### У результаті вивід буде наступний: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/segments.png)

Ось окремо про кожен сегмент:

Сегмент text — це місце, де зберігається сам код програми, тобто команди, які виконує процесор.

Сегмент data — це область пам’яті, де зберігаються глобальні та статичні змінні, яким одразу надано значення.

Сегмент BSS — це область для неініціалізованих глобальних змінних.

DEC — це загальний розмір цих сегментів у десятковій системі числення.

HEX  — те саме, тільки у шістнадцятковій системі числення.

Наступним кроком в цьому завданні було оголошення масиву. 
### [Код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_1.c) вже мав наступний вигляд: 

Повторюємо вимірювання і у результаті маємо вивід:

### ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/with%20global%20array_1.png)

Та

### ![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/with%20global%20array.png)

BSS значно збільшився з 1856 до 5856. Це пояснюється тим, що масив оголошено, але не ініціалізовано. Він не займає місце у виконуваному файлі, але програма резервує під нього пам’ять під час виконання.

Третім кроком було надання значення масиву. 

### [Переглянути код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_2.c)

### Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_2.png)

Тут вже BSS повернувся до 1856, бо масив тепер ініціалізований і перемістився у сегмент data. Data виріс з 440 до 4448, оскільки тепер дані знаходяться у виконуваному файлі. Файл збільшився в розмірі, бо тепер у ньому зберігаються значення масиву.

Наступний етап це оголошення великого масиву в локальну функцію та другого великого локального масиву з ініціалізатором.

### [Переглянути код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_3.c):

### Результат: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task2/PR22_3.png)

І на останньому етапі Text зріс із 1161 до 1270 — можливо, через додавання нової функції. BSS виріс із 1856 до 5744, бо додано статичні змінні, що не мають ініціалізованих значень. Data не змінився, бо статичний масив із ініціалізацією вже обліковувався раніше.

#### Чи залишаються дані у виконуваному файлі, якщо вони знаходяться всередині функцій?

Якщо змінні знаходяться всередині функцій, вони можуть залишатися у виконуваному файлі, але все залежить від їхнього типу. Якщо це звичайні локальні змінні (наприклад, int localArray[1000];), вони з’являються тільки під час виконання програми й не впливають на розмір файлу. Якщо змінна оголошена як static, вона зберігається в спеціальній області пам’яті та вже є частиною файлу, особливо якщо вона має початкове значення.

#### Яка різниця між ініціалізованим і неініціалізованим масивом?

Різниця між ініціалізованим і неініціалізованим масивом така: якщо просто оголосити масив, але не дати йому значень, він потрапить у пам’ять тільки під час виконання програми, тому файл не стане більшим. Але якщо масив одразу отримує значення (int globalArray[1000] = {1};), ці дані зберігаються прямо у виконуваному файлі, тому він займає більше місця.

#### Чому змінився розмір виконуваного файлу?

Розмір файлу змінюється тому, що ініціалізовані дані повинні десь зберігатися ще до запуску програми, а значить, вони додаються у файл. Неініціалізовані масиви просто резервують місце в пам’яті під час роботи програми, тому на розмір файлу вони майже не впливають.

#### Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?

Коли я компілюю програму для налагодження, її розмір значно збільшується, тому що у файл додається купа додаткової інформації. Сам код при цьому не змінюється, тому розміри сегментів text, data і bss зазвичай залишаються такими ж, але сам виконуваний файл стає набагато більшим. А якщо я компілюю з максимальною оптимізацією, то файл, навпаки, може стати меншим. Компілятор видаляє зайвий код, спрощує, використовує швидші алгоритми і краще працює з пам’яттю. У результаті сегмент text часто зменшується, бо код займає менше місця. Сегменти data і bss теж можуть трохи змінитися, якщо компілятор вирішить інакше розташувати змінні. 

# Завдання 2.3

Скомпілюйте й запустіть тестову програму, щоб визначити приблизне розташування стека у вашій системі:

#include <stdio.h>

int main() {
        int i;
        printf(&quot;The stack top is near %p\n&quot;, &amp;i);
        return 0;
}

Знайдіть розташування сегментів даних і тексту, а також купи всередині сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і виведіть їхні адреси. Збільшіть розмір стека, викликавши функцію й оголосивши кілька великих локальних масивів. Яка зараз адреса вершини стека?

## Виконання 

Перш за все компілюємо запропонований [код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task3/PR23.c).

### У результаті чого:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task3/PR23.png)

Далі визначаю розташування сегментів даних, тексту та купи. Я оголосила змінні, щоб перевірити їх розташування. 

[Переглянути код](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task3/PR23_1.c).

### Результат: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task3/PR23_1.png)

У  Text segment зберігається код програми. Адреса 0x2017a0 вказує на початок функції function. Data segment, initialized зберігає глобальні змінні, які мають ініціалізовані значення. global_var розташований за адресою 0x203aa8. У BSS segment містяться глобальні змінні, які не були ініціалізовані. var знаходиться за адресою 0x203b00. У static знаходяться статичні змінні, зокрема static_var, за адресою 0x203aac. Heap використовується для динамічного виділення пам'яті. У нашому випадку heap_var отримала адресу 0x1cddac08008. Stack це місце зберігання локальних змінних. local_var має адресу 0x820356148.

# Завдання 2.4

Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви можете:

    ● Автоматично за допомогою утиліти gstack.
    
    ● Вручну за допомогою налагоджувача GDB.
    
Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання (Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути pstack). Якщо gstack не працює, використовуйте другий метод – через
GDB, як показано нижче. Спочатку подивіться на стек за допомогою gstack(1). Нижче наведений приклад стека bash (аргументом команди є PID процесу): $ gstack 14654

#0 0x00007f359ec7ee7a in waitpid () from /lib64/libc.so.6

#1 0x000056474b4b41d9 in waitchild.isra ()

#2 0x000056474b4b595d in wait_for ()

#3 0x000056474b4a5033 in execute_command_internal ()

#4 0x000056474b4a5c22 in execute_command ()

#5 0x000056474b48f252 in reader_loop ()

#6 0x000056474b48dd32 in main ()

$

Розбір стека:

    ● Номер кадру стека відображається ліворуч перед символом #.
    
    ● Кадр #0 – це найнижчий кадр. Читайте стек знизу вверх (тобто від main() – кадр #6 – до waitpid() – кадр #0).
    
    ● Якщо процес багатопотоковий, gstack покаже стек кожного потоку окремо.
    
Аналіз стека в режимі користувача через GDB

Щоб переглянути стек процесу вручну, використовуйте GDB, приєднавшись до процесу. Нижче наведена невелика тестова програма на C, що виконує кілька вкладених викликів функцій. Граф викликів виглядає так:

main() --&gt; foo() --&gt; bar() --&gt; bar_is_now_closed() --&gt; pause()

Системний виклик pause() – це приклад блокуючого виклику. Він переводить викликаючий процес у сплячий режим, очікуючи (або блокуючи) сигнал. У цьому випадку процес блокується, поки не отримає будь-який сигнал.

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

#define MSG &quot;In function %20s; &amp;localvar = %p\n&quot;

static void bar_is_now_closed(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    printf("\n Now blocking on pause()...\n");

    pause();
}

static void bar(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar_is_now_closed();
}

static void foo(void) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    bar();
}

int main(int argc, char **argv) {
    int localvar = 5;
    printf(MSG, FUNCTION, &localvar);
    foo();
    exit(EXIT_SUCCESS);
}

Тепер відкрийте GDB. У ньому підключіться (attach) до процесу (в наведеному прикладі PID = 24957) і дослідіть стек за допомогою команди backtrace (bt):

$ gdb --quiet

(gdb) attach 24957

Attaching to process 24957

Reading symbols from &lt;...&gt;/hspl/unit2/stacker...done.

Reading symbols from /lib64/libc.so.6...Reading symbols from

/usr/lib/debug/usr/lib64/libc-2.26.so.debug...done.

done.

Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols

...

(gdb) bt

...

Примітка: В Ubuntu, через питання безпеки, GDB не дозволяє підключатися до довільного процесу. Це можна обійти, запустивши GDB від імені користувача root.

Аналіз того ж процесу через gstack

$ gstack 24957

...

gstack — це, по суті, оболонковий скрипт (wrapper shell script), який неінтерактивно викликає GDB і запускає команду backtrace, яку ви щойно використали.

Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.

## Виконання

Стек — це структура даних, у якій зберігається інформація про виклики функцій під час виконання програми. Він працює за принципом "останній прийшов — перший пішов".

У цьому завданні було використано дві методики аналізу стека процесу:

•	Автоматичний аналіз за допомогою команди gstack

•	Ручний аналіз через GDB (GNU Debugger)

### Створила файл з запропонованим [кодом](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task4/PR24.c).

Компілюю код:

clang -Wall -g PR24.c -o PR24

### Результат: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task4/PR24.png)

Далі аналізую стек за допомогою gdb. Запускаємо наступним чином:

gdb –quiet

(gdb) attach 24957

(gdb) bt

### Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr2/task4/PR24_1.png)

Зараз розшифрую вивід:

#0 – найнижчий кадр (процес заблокований у sigsuspend()).

#1 – функція pause() (чекає на сигнал).

#2 – виклик bar_is_now_closed().

#3 – виклик bar().

#4 – виклик foo().

#5 – виклик main().
