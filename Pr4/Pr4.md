# Завдання 4.1

Скільки пам’яті може виділити malloc(3) за один виклик?
Параметр malloc(3) є цілим числом типу даних size_t, тому логічно максимальне число, яке можна передати як параметр malloc(3), — це максимальне значення size_t на платформі (sizeof(size_t)). У 64-бітній Linux size_t становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик malloc(3), дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

## Виконання

Перш за все я дізналась розмір size_t у FreeBSD [написавши код](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task1/PR4_1.c). Скомпілювала його і отримала результат: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task1/PR4_1.png)

Після цього пишу код який буде намагатись виділити велику кількість.

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task1/PR4_1_1.png)

А що стосується питання чому теоретично максимальний обсяг складає 8 ексабайт, а не 16, то на 64-бітних системах size_t займає 8 байтів. До того ж теоретично максимальне значення size_t – 2^64-1(18.4 EБ). Тому практично malloc(3) не може видітили більше 8 ЕБ.

Перевірка:

Sysctl hw.physmem

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task1/PR4_111.png)

# Завдання 4.2

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

## Виконання

#### Що станеться, якщо передати malloc(3) від’ємний аргумент? 

Функція malloc(3) приймає параметр типу size_t, який є беззнаковим (unsigned). Якщо передати від’ємне значення, воно буде неявно перетворене в size_t, що призведе до дуже великого числа. Це призведе до помилки.
Далі написала тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Завдяки цьому [коду](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task2/PR4_2.c) ми перевіримо, що станеться, якщо перемножити два знаковий значення та отримати від’ємний результат, який буде передано у malloc(3).

Після компіляції отримуємо: 

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task2/PR4_2.png)

#### Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення?

Якщо num має тип int або long і результат множення двох великих чисел перевищує максимальне значення, то відбувається переповнення знакового типу

#### Як себе поведе malloc(3)? 

malloc(3) приймає аргумент типу size_t, який є беззнаковим. Виходячи з цього від’ємне значення сприймається як дуже велике позитивне число. Відповідно виникне помилка виділення пам’яті. 

# Завдання 4.3

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

## Виконання

#### Що станеться, якщо передати malloc(3) від’ємний аргумент? 

Функція malloc(3) приймає параметр типу size_t, який є беззнаковим (unsigned). Якщо передати від’ємне значення, воно буде неявно перетворене в size_t, що призведе до дуже великого числа. Це призведе до помилки.
Далі написала тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa malloc(0) може поводитися по-різному залежно від реалізації malloc(3) у FreeBSD. Або ж malloc(0) повертає NULL, що означає, що виділення пам’яті не відбулося. Або ж повертає непорожній (не NULL) вказівник, який можна безпечно передати у free(). 

Пишу тестовий випадок у якому malloc(0) повертає NULL або вказівник, що не є NULL, і який можна передати у free().

Компілюємо:

malloc(0) returned a valid pointer: 0x1b0ae1808008 

Pointer freed successfully.

І далі запускаємо через Itrace. Спочатку захожу в рут права і встановлюю Itrace:

Sudo pkg install Itrace

Запускаємо і у результаті бачимо, що програма викликала malloc(0), і функція malloc() повернула вказівник 0x3e3ad4800808 замість NULL. Це означає, що навіть для malloc(0) система виділила певний керований службовий блок пам’яті.

# Завдання 4.4

Чи є помилки у такому коді?

void *ptr = NULL;

while (<some-condition-is-true>) {

    if (!ptr)
    
        ptr = malloc(n);
        
    [... <використання 'ptr'> ...]
    
    free(ptr);
}

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

## Виконання

Помилка в коді полягає в тому, що ptr звільняється у free(ptr) в кінці циклу. Але вже в наступній ітерації умова if (!prt) не спрацьовує, бо prt вже отримав значення, при тому що воно недійсне після free(ptr). 
Пишемо програму яка продемонструє помилку, ми виділяємо пам'ять один раз всередині циклу, але після звільнення пам'яті намагаємося знову використовувати той самий вказівник без перевизначення. Кожен виклик free(ptr) викликає звільнення пам'яті. Якщо цикл виконується кілька разів, пам'ять буде звільнена кілька разів. І отримаємо помилку:

Iteration 1, ptr = 0x26e417213000

Iteration 2, ptr = 0x26e417213000

Далі пишемо правильний код. Ми виділяє пам’ять один раз в циклі. Пам’ять звільняється лише після завершення циклу. Якщо пам’ять не вдалося виділити за допомогою malloc, програма виведе повідомлення про помилку.

#include <stdio.h>

#include <stdlib.h>

int main() {

    void *ptr = NULL;
    
    for (int i = 0; i < 2; ++i) {
    
        if (!ptr) {
        
            ptr = malloc(10); 
            
            if (!ptr) {
            
                perror("malloc failed");
                
                return 1; 
                
            }
            
            printf("Memory allocated\n");
            
        }
        
        if (ptr) {
        
            printf("Using ptr in iteration %d\n", i + 1);
            
        }
        
        if (i == 1) {
        
            free(ptr);
            
            printf("Memory freed\n");
            
        }
        
    }
    
    return 0;
    
}


Результат:

Memory allocated

Using ptr in iteration 1

Using ptr in iteration 2

Memory freed

"Memory allocated": це повідомлення виводиться тільки в першій ітерації циклу, коли пам'ять виділяється через malloc.

"Using ptr in iteration X": це повідомлення виводиться в обох ітераціях, оскільки пам'ять була виділена, і вказівник ptr не є NULL.

"Memory freed": це повідомлення виводиться тільки в останній ітерації (коли i == 1), коли виконується звільнення пам'яті через free(ptr).

# Завдання 4.5

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

## Виконання

Якщо realloc() не зможе виділити новий блок пам’яті, він поверне NULL, а початковий вказівник залишиться без змін. Далі пишу [тестовий випадок](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task5/PR4_5.c) в якому викличу realloc() із дуже великим розміром пам’яті, щоб змусити його повернути NULL. 

Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task5/PR4_5.png)

Це означає, що початкова malloc(1024) успішно виділила пам’ять. Виводиться адреса виділеної області. А realloc(ptr, huge_size) не зміг виділити пам’ять, тому повернув NULL. perror("realloc failed") друкує "Cannot allocate memory", це стандартне повідомлення системи, коли пам’яті недостатньо.

# Завдання 4.6

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

## Виконання

Якщо передати у realloc() вказівник NULL, функція просто працюватиме як malloc() і виділить нову область пам’яті потрібного розміру. Якщо ж передати 0 як розмір, просто звільнитися пам’ять (free(ptr)) і повернеться NULL. Пишу [тестовий варіант:](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task6/PR4_6.c)

і у результаті:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task6/PR4_6.png)

Через специфічну поведінку jemalloc, realloc(ptr, 0) повертає не 0, а адресу, яку потім потрібно звільнити. 

# Завдання 4.7

Перепишіть наступний код, використовуючи reallocarray(3):

      struct sbar *ptr, *newptr;
      ptr = calloc(1000, sizeof(struct sbar));
      newptr = realloc(ptr, 500*sizeof(struct sbar));

Порівняйте результати виконання з використанням ltrace.

## Виконання

В запропонованому коді виділяється пам’ять для 1000 структур sbar за допомогою calloc, а потім змінює розмір виділеної пам’яті на 500 структур через realloc.

Далі [переписали код](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task7/PR4_7.c) з reallocarray(3)

reallocarray(3) це — це функція , яка динамічно змінює розмір виділеної області пам’яті. 

ltrace це — це утиліта, яка відстежує виклики бібліотечних функцій, які виконує програма.

Спочатку компілюю програму за допомогою компілятора clang і запускаю через ltrace. Для того, щоб побачити виклики до функцій динамічного виділення пам'яті, таких як calloc, realloc, і free.

#### Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task7/PR4_7.png)

#### Пояснення виводу:

calloc: виділяється пам'ять для 1000 елементів.

reallocarray: перерозподіл пам'яті для 500 елементів.

free: звільняється пам'ять після використання.

# Завдання 4.21

Перевірте роботу malloc у середовищі з обмеженим обсягом пам’яті.

## Виконання

Щоб перевірити роботу malloc слід обмежити доступну пам'ять для програми, а потім перевірити, як вона поводиться під час виділення пам'яті. Пишемо[тестову програму](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task4_21/PR4_21.c), яка використовує malloc для виділення пам'яті, а потім перевіряє, чи правильно працює виділення пам'яті в умовах обмеженого ресурсу.

Ця програма намагається виділити 100 МБ пам'яті. Якщо виділення пам'яті не вдається, вона виведе повідомлення про помилку.

Після цього запускаємо програму, і вона повинна спробувати виділити більше пам'яті, ніж дозволено. 

dasha@host: $ ulimit -v 51200 

dasha@host:~$ clang -o PR4_21 PR4_21.c

Total segment size exceeds process limit Abort trap

./PR4_21

malloc failed: Cannot allocate memory

#### Результат:

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr4/task4_21/PR4_21.png)
