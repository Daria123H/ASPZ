Посилання: https://github.com/Daria123H/ASPZ.git

# Завдання 8.1

Чи може виклик count = write(fd, buffer, nbytes); повернути в змінній count значення, відмінне від nbytes? Якщо так, то чому? Наведіть робочий приклад програми, яка демонструє вашу відповідь.

## Виконання

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_1/PR8_1.c), який відкриває файл testfile.txt для запису або створює його, якщо він не існує. Потім записує рядок "Hello, this is a test!" у файл за допомогою функції write. Після цього виводиться повідомлення про кількість байтів, які було спробувано записати, і скільки фактично було записано. Якщо під час відкриття файлу або запису виникає помилка, програма виводить повідомлення про помилку і завершується.

Після чого створюємо текстовий файл:

    ee PR8_1.txt

Компілюємо програму. 

    clang -o PR8_1 PR8_1.c
    ./PR8_1 

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_1/PR8_1.png)

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_1/PR8_11.png)

Функція write(fd, buffer, nbytes) може повернути значення в змінній count, яке менше за nbytes, якщо система не змогла записати всі байти за один раз, виникла помилка під час запису або є обмеження на кількість байтів, які можна записати. Тому count може бути меншим за nbytes, якщо не всі байти були записані або сталася помилка.

# Завдання 8.2

## Виконання

[Пишемо програму](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_2/PR8_22.c), яка створює файл з назвою PR8.bin. Якщо файл уже існує, він буде очищений. У файл записується послідовність байтів: 4, 5, 2, 2, 3, 3, 7, 9, 1, 5. Після запису файл закривається.
А також [пишемо програму](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_2/PR8_2.c), у яка відкриває файл PR8.bin для читання. Потім за допомогою lseek переміщує покажчик файлу на третій байт (рахуючи від нуля). Після цього читає 4 байти у буфер. Зчитані байти виводяться на екран як беззнакові цілі числа через пробіл.

Після чого компылюэмо спочатку перший код,а вже потім другий:
     clang -o PR8_22 PR8_22.c
    ./PR8_22 
     clang -o PR8_2 PR8_2.c
    ./PR8_2

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_2/PR8_44.png)


# Завдання 8.3

Бібліотечна функція qsort призначена для сортування даних будь-якого типу. Для її роботи необхідно підготувати функцію порівняння, яка викликається з qsort кожного разу, коли потрібно порівняти два значення. Оскільки значення можуть мати будь-який тип, у функцію порівняння передаються два вказівники типу void* на елементи, що порівнюються.
 
Напишіть програму, яка досліджує, які вхідні дані є найгіршими для алгоритму швидкого сортування. Спробуйте знайти кілька масивів даних, які змушують qsort працювати якнайповільніше. Автоматизуйте процес експериментування так, щоб підбір і аналіз вхідних даних виконувалися самостійно.

Придумайте і реалізуйте набір тестів для перевірки правильності функції qsort.

## Виконання

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_3/PR8_3.c),який допоможе дослідити, як швидко працює алгоритм швидкого сортування (qsort) з різними типами даних. Моя програма генерує три типи масивів: масив у порядку спадання (найгірший випадок для сортування), вже відсортований масив і випадковий масив. Програма сортує кожен з цих масивів за допомогою qsort і вимірює час сортування. Потім перевіряється, чи правильно відсортовано масив. Крім того, програма запускає 1000 експериментів на випадкових масивах і знаходить найгірший час сортування серед них. Це дозволяє зрозуміти, який тип даних може уповільнити роботу алгоритму.

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_3/PR8_3.png)

        worst case scenario: time = 0.00000 seconds - Sorting is correct

Для найгіршого випадку (масив у порядку спадання), алгоритм швидко виконав сортування. Время сортування стало 0.00000 секунд, що вказує на те, що сортування відбулося майже миттєво. Також зазначено, що сортування є правильним, що означає, що після виконання сортування масив став відсортованим за зростанням.

        an already sorted array: time = 0.00000 seconds - Sorting is correct

Для вже відсортованого масиву, сортування також виконано за 0.00000 секунд. Це також означає, що сортування відбулося дуже швидко, і результат є правильним.

        Random array: time = 0.00000 seconds - Sorting is correct

Для випадкового масиву час сортування також 0.00000 секунд, що є дуже швидким. В результаті масив був відсортований правильно.

        Worst time among 1000 experiments: 0.00781 second

У 1000 експериментах для випадкових масивів було знайдено найгірший час сортування 0.00781 секунд. Це означає, що серед великої кількості тестів для випадкових масивів максимальний час сортування становив 0.00781 секунд.

# Завдання 8.4

 Виконайте наступну програму на мові програмування С:
 
int main() {

  int pid;
  
  pid = fork();
  
  printf("%d\n", pid);
  
}

Завершіть цю програму. Припускаючи, що виклик fork() був успішним, яким може бути результат виконання цієї програми?

## Виконання

[Переписуємо код](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_4/PR8_4.c). 

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_4/PR8_4.png)

Програма використовує функцію fork(), яка створює новий процес, копіюючи поточний. Після виклику fork() програма продовжує виконуватись як у батьківському, так і в дочірньому процесі. Для батьківського процесу функція fork() повертає ідентифікатор процесу (PID) дочірнього процесу, тобто ненульове значення. Для дочірнього процесу функція fork() повертає 0.

Для батьківського процесу це буде PID дочірнього процесу, тобто в моєму випадку це 1040

Для дочірнього процесу це буде 0.


# Завдання 8.21

Реалізуйте аналог tail -f без використання select(), poll() або inotify.

## Виконання

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr8/Pr8_21.c) у якому реалізовано спрощений аналог команди tail -f, яка дозволяє переглядати останні рядки з текстового файлу та автоматично виводити нові рядки, що додаються до файлу. Користувач має передати шлях до файлу як аргумент при запуску програми. Якщо аргумент не передано, виводиться повідомлення про правильний формат запуску. Далі за допомогою функції open() файл відкривається для читання. Якщо файл не відкривається, програма виводить помилку і завершується. Головна логіка полягає в тому, щоб знайти останні 10 рядків файлу і вивести їх. Для цього використовується функція lseek(), яка переміщує курсор читання в кінець файлу. Потім відбувається зворотне зчитування символ за символом, і коли знаходяться 10 символів нового рядка (\n), зупиняється пошук. Таким чином, програма "відмотує" файл назад і знаходить місце, з якого потрібно почати показувати текст. Після цього з цієї точки вперед файл зчитується у буфер і виводиться на екран за допомогою write(). Буфер має фіксований розмір, і після кожного зчитування його вміст виводиться на стандартний вивід (тобто в термінал). Коли останні 10 рядків уже виведені, програма переходить до режиму постійного моніторингу. Вона знову переміщає курсор у кінець файлу і постійно перевіряє, чи з’явилися нові дані. Якщо щось нове зчитується з файлу, це відразу виводиться на екран. Якщо нових даних немає, програма просто чекає 1 секунду і пробує знову. Таким чином, нові рядки автоматично з’являються на екрані, коли вони дописуються у файл.

Після чого створюємо файл:

    ee PR8_21.txt

Записуємо туди текст і компілюємо програму. 

    clang -o PR8_21 PR8_21.c
    ./PR8_21 PR8_21.txt 

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr8/PR8_21.png)

Вивелось останній 9 рядків + пустий, бо файл має символ нового рядка (\n) наприкінці, тому програма припустила, що це ще один рядок, який потрібно вивести, навіть якщо це просто порожній рядок.
