# Завдання 6.21

Напишіть короткий звіт (до 1 сторінки): “Valgrind vs ASan — що краще для великих програм? Для CI/CD? Для роботи з Docker?” 

## Виконання

Valgrind - це програма, яка запускає програму під моїм наглядом. Вона перевіряє, чи є витоки пам’яті або помилки доступу.

ASan- це вбудований у компілятор інструмент (як частина GCC або Clang), який додає додаткові перевірки прямо в код під час компіляції. 

### Для великих програм

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_11.c), який буде виконувати операції з виділенням і звільненням пам'яті, але мати помилку, яка призводитиме до виходу за межі виділеного масиву. 

#### ASan компіляція (Clang):

    clang -fsanitize=address -g PR6_11.c -o PR6_11

    ./big

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_11Asan.png)

fa — це захисна зона пам’яті, яку створює AddressSanitizer (ASan), щоб виявити помилки. Програма вилетіла (==967==ABORTING), бо вона звернулась до цієї забороненої зони — отже, є помилка в роботі з пам’яттю (наприклад, вихід за межі масиву або помилка з malloc).

#### Valgrind запуск:

    cc PR6_11.c -o PR6_11

    valgrind ./ PR6_11

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_11Va.png)

Valgrind працює дуже повільно, тому якщо у мене великий проєкт, тестування займе багато часу. Але його не потрібно компілювати з якимись особливими опціями, просто треба запустити програму.

ASan працює набагато швидше, і краще підходить для великих програм, які треба перевіряти регулярно. Але її потрібно скомпілювати з опцією -fsanitize=address.

Висновок: для великих програм краще ASan — швидше і легше інтегрується.

#### Для CI/CD

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_12.c),що виділяє пам'ять для одного цілого числа, звільняє її, а потім намагається записати значення в уже звільнену пам'ять.

#### ASan компіляція:

    clang -fsanitize=address -g ci.c -o ci

    ./ci

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_12.png)

Програма звернулася до пам’яті, яка знаходиться поза межами дозволеного блоку (до "червоної зони" fa). Це призводить до аварійного завершення програми (ABORTING). =1050 — код помилки завершення процесу.

Valgrind може бути занадто повільним. Також він дає дуже детальні звіти, але довго працює.

ASan легко вбудовується в CI, треба просто додати опцію компілятора, і як результат детальні звіти про помилки.

Висновок: У CI/CD найкращий варіант — ASan.

### Для роботи з Docker

Valgrind виконує точний аналіз пам'яті (витоки, некоректні доступи).Але при цьому повільний, сповільнює роботу програми, і важко інтегрується з Docker.

AddressSanitizer (ASan) в свою ж чергу навпаки швидший, легко інтегрується з Docker, дає точні результати для помилок пам'яті. Але може бути менш точним для деяких помилок, як витоки пам'яті.

ASan зазвичай краще, бо працює швидше і простіше інтегрується.

[Пишемо код](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_13.c), який виділяє динамічну пам'ять для масиву з трьох цілих чисел, а потім помилково записує значення за межами цього масиву.

Компілюємо з AddressSanitizer:

        clang -fsanitize=address -g PR6_13.c -o PR6_13
        ./PR6_13

## Результат

![Результат](https://github.com/Daria123H/ASPZ/blob/main/Pr6/PR6_13.png)

ASan зловив саме таку помилку — вихід за межі масиву, тобто програма записала значення в частину пам’яті, яка їй не належить. fa fa fa ... — це так званий "redzone", особлива область пам’яті, яку ASan ставить навколо масивів, щоб «піймати» такі помилки. Якщо програма залізла в fa, значить, вона переписала захищену зону, тобто зробила помилку. І тому внизу видно ==944==ABORTING — програма аварійно завершилась, бо ASan зупинив її, щоб не було ще гірше.
